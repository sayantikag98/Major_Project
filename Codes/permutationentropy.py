# -*- coding: utf-8 -*-
"""PermutationEntropy.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TdBl-HvPrWpIRl-ssf5eTbTJ7QDW3gyp
"""

from google.colab import drive 
drive.mount('drive', force_remount = False)

pip install ordpy

import pandas as pd
import numpy as np
import time
import seaborn as sns
import matplotlib.pyplot as plt
import sklearn
from scipy.io import loadmat
from sklearn.model_selection import train_test_split
import scipy
from sklearn import preprocessing
import random
import ordpy
from scipy import signal

font = {
  'weight':'bold',
  'size' : 25 
}
plt.rc('font', **font)

def create_csv(path):
  data = loadmat(path)
  time_list = []
  for i in range(len(data['t'])):
    for j in data['t'][i]:
      time_list.append(j)
  acc_list = []
  for i in range(len(data['d'])):
    acc_list.append(data['d'][i][4])
  df = pd.DataFrame({'time':time_list,'acc_x':acc_list})
  return df

def resample_acc_x (acc_list):
  i = 0
  j = 16
  avg_acc_list = []
  while(j<len(acc_list)):
    sum = 0
    count = 0
    for k in range(i,j):
      sum += acc_list[k]
      count += 1
    avg = sum/count
    avg_acc_list.append(avg)
    i += 16
    j += 16
  sum = 0
  count = 0
  for k in range(i, len(acc_list)):
    sum += acc_list[k];
    count += 1
  avg = sum/count
  avg_acc_list.append(avg)
  time_list = []
  i = 0
  count = 0
  while(count<len(avg_acc_list)):
    time_list.append(i)
    i += (1/10000)
    count += 1
  df = pd.DataFrame({'time':time_list, 'acc_x':avg_acc_list})
  return df

def plot(df, ti):
  plt.figure(figsize = (110, 30))
  plt.plot(df.time, df.acc_x)
  plt.xlabel('time')
  plt.ylabel('acceleration_x')
  plt.savefig(ti)
  plt.show()

def data_func(path, ti, ti_1):
  df = create_csv(path)
  acc_x_list = df.acc_x.tolist()
  acc_x_list_copy = acc_x_list

  # ####### for resampling of data without filtering the data #######
  df = resample_acc_x(acc_x_list)
  acc_x_list = df.acc_x.tolist()
  # #################################################################

  sos = signal.butter(10, 1/8, 'low', analog = False, output = 'sos')
  filtered = signal.sosfilt(sos, acc_x_list_copy)
  filtered = filtered.tolist()
  # df_filtered = pd.DataFrame({'time':df['time'],'acc_x':filtered})

  # ####### for resampling of data with filtering the data #######
  # acc_x_list_fil = df_filtered.acc_x.tolist()
  df_filtered = resample_acc_x(filtered)
  # ##################################################################

  plot(df, ti)
  plot(df_filtered, ti_1)
  acc_x_list_filtered = df_filtered['acc_x'].tolist()
  acc_x_list1 = acc_x_list_filtered[0:1000000]
  acc_x_list_11 = acc_x_list[0:1000000]
  return df, df_filtered, acc_x_list1, acc_x_list_11

"""# Overlapping Window of size 1024"""

def helper_func(x):
  i = 0
  j = 1024
  sublist = []
  while (j<=len(x)):
    lis = x[i:j]
    sublist.append(lis)
    i+=1
    j+=1
  return sublist

def func_overlap(acc_x_list):
  i = 0
  j = 50000
  lis = []
  while(j<=len(acc_x_list)):
    x = acc_x_list[i:j]
    lis += helper_func(x)
    i = j - 1023
    j = i + 50000
  x = acc_x_list[i:len(acc_x_list)]
  lis += helper_func(x)
  return lis

def per_ent_ov(lis):
  permutation_entropy_list = []
  for i in range(len(lis)):
    val = ordpy.permutation_entropy(lis[i])
    print(val)
    permutation_entropy_list.append(val)
  return permutation_entropy_list

"""# Not Overlapping Window of size 1024"""

def per_ent_nov(acc_x_list):
  permutation_entropy_list = []
  i = 0
  j = 1024
  time_count = 0
  while(j<len(acc_x_list)):
    t_start = time.time()
    val = ordpy.permutation_entropy(acc_x_list[i:j])
    t_end = time.time()
    time_count+=(t_end - t_start)
    permutation_entropy_list.append(val)
    i = j
    j+= 1024
  time_elapsed = time_count/len(permutation_entropy_list)
  print("The time taken to calculate the value of permutation entropy for a window of size 1024 samples within a time-span of 100 microseconds is {} seconds".format(time_elapsed))
  return permutation_entropy_list

def index_list_func(permutation_entropy_list):
  window_list = []
  for i in range(len(permutation_entropy_list)):
    window_list.append(i)
  return window_list

def plot_ov(permutation_entropy_list, window_list, st, ti):
  plt.figure(figsize = (150, 50))
  plt.plot(window_list, permutation_entropy_list, linewidth = 5)
  plt.title(st)
  # zip joins x and y coordinates in pairs
  for x,y in zip(window_list, permutation_entropy_list):

    label = "{},{:.2f}".format(x,y)

    plt.annotate(label, # this is the text
                 (x,y), # this is the point to label
                 textcoords="offset points", # how to position the text
                 xytext=(0,10), # distance from text to points (x,y)
                 ha='center') # horizontal alignment can be left, right or center
  plt.xlabel('Windows', fontsize = 30)
  plt.ylabel('Permutation_Entropy', fontsize = 30)
  plt.savefig(ti)
  plt.show()

def permutation_entropy_cal_and_plot_from_raw_for_overlapping(acc_x_list):
  lis = func_overlap(acc_x_list)
  permutation_entropy_list = per_ent_ov(lis)
  return permutation_entropy_list

def permutation_entropy_cal_and_plot_from_raw_for_non_overlapping(acc_x_list):
  permutation_entropy_list = per_ent_nov(acc_x_list)
  return permutation_entropy_list

"""# time to frequency conversion"""

def time_2_freq_conversion(df, ti):
    Fx = np.array(df.acc_x)
    X = scipy.fft.fft(Fx)
    # print(X)
    N = len(X)
    # print(N)
    n = np.arange(N)
    # print(n)
    # get the sampling rate
    sr = 1 / (10000)
    # print(sr)
    T = N/sr
    # print(T)
    freq = n/T
    # print(freq) 

    # Get the one-sided specturm
    n_oneside = N//2
    # print(n_oneside)
    # get the one side frequency
    f_oneside = freq[:n_oneside]
    # print(f_oneside)

    plt.figure(figsize = (60, 10))
    plt.plot(f_oneside, np.abs(X[:n_oneside]), 'b')
    # plt.xlim(0, 1*(1e-5))
    # plt.ylim(0, 0.5*(1e7))
    st = "Frequency_"
    st+="acc_x"
    st+=" (Hz)"
    plt.xlabel(st)
    st = "FFT Amplitude |"
    st+= "acc_x"
    st+="(freq)|"
    plt.ylabel(st)
    plt.savefig(ti)
    plt.show()

"""# Cutting speed = 1030 rpm, DOC = 0.001 inches


"""

path = "drive/MyDrive/cutting_tests_raw/timeSeries_2inchStickout/F_08-Jun-2017_rpm1030_doc0p001.mat"
ti = "time_domain_plot_for_unfiltered_resampled_data_rpm_1030_doc_001.png"
ti_1 = "time_domain_plot_for_filtered_resampled_data_rpm_1030_doc_001.png"
df, df_filtered, acc_x_list_filtered, acc_x_list_unfiltered = data_func(path, ti, ti_1)

"""## For overlapping windows"""

# permutation_entropy_list_overlapping = permutation_entropy_cal_and_plot_from_raw_for_overlapping(acc_x_list_unfiltered)
# index_list = index_list_func(permutation_entropy_list_overlapping)

# plot_ov(permutation_entropy_list_overlapping, index_list, "Plot for overlapping windows", "Plot_for_overlapping_windows_for_unfiltered_resampled_data_rpm_1030_doc_001_part1_new.png")

"""## For non-overlapping window"""

permutation_entropy_list_non_overlapping = permutation_entropy_cal_and_plot_from_raw_for_non_overlapping(acc_x_list_unfiltered)
index_list = index_list_func(permutation_entropy_list_non_overlapping)

plot_ov(permutation_entropy_list_non_overlapping, index_list, "Plot for non-overlapping windows",  "Plot_for_non_overlapping_windows_for_unfiltered_resampled_data_rpm_1030_doc_001_part1.png")

time_2_freq_conversion(df, "plot_of_frequency_spectrum_for_unfiltered_data_rpm_1030_doc_001.png")

time_2_freq_conversion(df_filtered, "plot_of_frequency_spectrum_for_filtered_resampled_data_rpm_1030_doc_001.png")

"""# Cutting speed = 320 rpm, DOC = 0.005 inches


"""

path = "drive/MyDrive/cutting_tests_raw/timeSeries_2inchStickout/F_08-Jun-2017_rpm320_doc0p005.mat"
ti = "time_domain_plot_for_unfiltered_resampled_data_rpm_320_doc_005_png"
ti_1 = "time_domain_plot_for_filtered_resampled_data_rpm_320_doc_005.png"
df, df_filtered, acc_x_list_filtered, acc_x_list_unfiltered = data_func(path, ti, ti_1)

"""## For overlapping windows"""

# permutation_entropy_list_overlapping = permutation_entropy_cal_and_plot_from_raw_for_overlapping(acc_x_list_unfiltered)
# index_list = index_list_func(permutation_entropy_list_overlapping)

# plot_ov(permutation_entropy_list_overlapping, index_list, "Plot for overlapping windows", "Plot_for_overlapping_windows_for_unfiltered_resampled_data_rpm_320_doc_005_part1_new.png")

"""## For non-overlapping window"""

permutation_entropy_list_non_overlapping = permutation_entropy_cal_and_plot_from_raw_for_non_overlapping(acc_x_list_unfiltered)
index_list = index_list_func(permutation_entropy_list_non_overlapping)

plot_ov(permutation_entropy_list_non_overlapping, index_list, "Plot for non-overlapping windows",  "Plot_for_non_overlapping_windows_for_unfiltered_resampled_data_rpm_320_doc_005_part1.png")

time_2_freq_conversion(df, "plot_of_frequency_spectrum_for_unfiltered_resampled_data_rpm_320_doc_005.png")

time_2_freq_conversion(df_filtered, "plot_of_frequency_spectrum_for_filtered_resampled_data_rpm_320_doc_005.png")

def create_csv_processed(path):
  data = loadmat(path)
  df = pd.DataFrame(data['tsDS'], columns = ['time', 'acc_x'])
  return df

def permutation_entropy_processed_overlapping(path):
  df = create_csv_processed(path)
  acc_x_list = df.acc_x.tolist()
  lis = func_overlap(acc_x_list)
  permutation_entropy_list = per_ent_ov(lis)
  return permutation_entropy_list

def permutation_entropy_processed_nonoverlapping(path):
  df = create_csv_processed(path)
  acc_x_list = df.acc_x.tolist()
  permutation_entropy_list = per_ent_nov(acc_x_list)
  return permutation_entropy_list

# permutation_entropy_overlapping = permutation_entropy_processed_overlapping("drive/MyDrive/cutting_tests_processed/2inch_stickout/c_425_025.mat")

# plot_ov(permutation_entropy_overlapping, "Plot for overlapping windows", "permutation_entropy_plot_for_processed_data_2p0_c_425_025.png")

# permutation_entropy_non_overlapping = permutation_entropy_processed_nonoverlapping("drive/MyDrive/cutting_tests_processed/2inch_stickout/c_425_025.mat")

# plot_ov(permutation_entropy_non_overlapping, "Plot for non-overlapping windows", "permutation_entropy_plot_for_processed_data_non_overlapping_2p0_c_425_025.png")

# permutation_entropy_overlapping = permutation_entropy_processed_overlapping("drive/MyDrive/cutting_tests_processed/2inch_stickout/c_570_001.mat")

# plot_ov(permutation_entropy_overlapping, "Plot for overlapping windows", "permutation_entropy_plot_for_processed_data_2p0_c_570_001.png")

# permutation_entropy_non_overlapping = permutation_entropy_processed_nonoverlapping("drive/MyDrive/cutting_tests_processed/2inch_stickout/c_570_001.mat")

# plot_ov(permutation_entropy_non_overlapping,"Plot for non-overlapping windows", "permutation_entropy_plot_for_processed_data_non_overlapping_2p0_c_570_001.png")

# permutation_entropy_overlapping = permutation_entropy_processed_overlapping("drive/MyDrive/cutting_tests_processed/2inch_stickout/s_320_005.mat")

# plot_ov(permutation_entropy_overlapping, "Plot for overlapping windows", "permutation_entropy_plot_for_processed_data_2p0_s_320_005.png")

# permutation_entropy_non_overlapping = permutation_entropy_processed_nonoverlapping("drive/MyDrive/cutting_tests_processed/2inch_stickout/s_320_005.mat")

# plot_ov(permutation_entropy_non_overlapping, "Plot for non-overlapping windows", "permutation_entropy_plot_for_processed_data_non_overlapping_2p0_s_320_005.png")

"""# 1 Window = 100 milliseconds approx"""

# df = create_csv_processed("drive/MyDrive/cutting_tests_processed/2inch_stickout/c_570_001.mat")

df.iloc[1023,0] - df.iloc[0,0]

1e-5

