# -*- coding: utf-8 -*-
"""Chatter_Detection_in_Turning.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15AeLnWYwBw7AveaGyK9RAaVCGsPkS2_K

#Importing required libraries
"""

pip install dtw-python

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import matplotlib.pyplot as plt
# %matplotlib inline
import seaborn as sns
import numpy as np
import sklearn
import scipy
from scipy import fftpack
from scipy.fft import fft, fftfreq
from numpy.fft import rfft, irfft, rfftfreq
from dtw import *

"""#Mounting Google Drive"""

from google.colab import drive
drive.mount('drive', force_remount= False)

class Chatter_Detection:
  def __init__(self):
    pass

  def helper_Func(self, path):
    df = pd.read_csv(path, sep = "\t")
    lis = []
    for i in range(19,len(df)):
      s = str(df.iloc[i,0])
      lis.append(s.split(","))
    df1 = pd.DataFrame(lis, columns=['time','Fx12','Fx34','Fy14','Fy23','Fz1','Fz2','Fz3','Fz4','Fx','Fy','Fz','Mx','My','Mz'])
    df1 = df1.loc[:,['time','Fx','Fy','Fz']]
    return df1

  
  def load_Data1(self):
    path = "drive/MyDrive/Max Condition Test_1_000.csv"
    df = self.helper_Func(path)
    return df

  def load_Data2(self):
    path = "drive/MyDrive/Max Condition Test_2_000.csv"
    df = self.helper_Func(path)
    return df

  def load_Data3(self):
    path = "drive/MyDrive/Max Condition Test_3_000.csv"
    df = self.helper_Func(path)
    return df

  def load_Data4(self):
    path = "drive/MyDrive/Max Condition Test_4_000.csv"
    df = self.helper_Func(path)
    return df

  def load_Data5(self):
    path = "drive/MyDrive/Max Condition Test_5_000.csv"
    df = self.helper_Func(path)
    return df

  def load_Data6(self):
    path = "drive/MyDrive/Max Condition Test_6_000.csv"
    df = self.helper_Func(path)
    return df

  def load_Data7(self):
    path = "drive/MyDrive/Max Condition Test_7_000.csv"
    df = self.helper_Func(path)
    return df


  def data_to_csv(self, df, st):
    s = "Data"
    s += st
    s += ".csv"
    df.to_csv(s, index = False)

  def load_DataFrame1(self):
    path = "drive/MyDrive/Data1.csv"
    df = pd.read_csv(path)
    return df

  def load_DataFrame2(self):
    path = "drive/MyDrive/Data2.csv"
    df = pd.read_csv(path)
    return df
  
  def load_DataFrame3(self):
    path = "drive/MyDrive/Data3.csv"
    df = pd.read_csv(path)
    return df

  def load_DataFrame4(self):
    path = "drive/MyDrive/Data4.csv"
    df = pd.read_csv(path)
    return df

  def load_DataFrame5(self):
    path = "drive/MyDrive/Data5.csv"
    df = pd.read_csv(path)
    return df

  def load_DataFrame6(self):
    path = "drive/MyDrive/Data6.csv"
    df = pd.read_csv(path)
    return df

  def load_DataFrame7(self):
    path = "drive/MyDrive/Data7.csv"
    df = pd.read_csv(path)
    return df



  def line_Plot(self, df, st):
    sns.set(font_scale=1.6)
    df.set_index('time', inplace = True)
    df.plot(subplots = True, figsize= (75,50))
    plt.legend(loc="upper right")
    s = "Line plot of Fx, Fy and Fz vs time for test run "
    s+= st
    plt.title(s, y=1.02)
    plt.xlabel("time",labelpad=15)
    plt.tick_params(pad=6)
    plt.show()

  
  def line_plot_data1(self, st):
    df = self.load_DataFrame1()
    self.line_Plot(df, st)

  def line_plot_data2(self, st):
    df = self.load_DataFrame2()
    self.line_Plot(df, st)

  def line_plot_data3(self, st):
    df = self.load_DataFrame3()
    self.line_Plot(df, st)

  def line_plot_data4(self, st):
    df = self.load_DataFrame4()
    self.line_Plot(df, st)

  def line_plot_data5(self, st):
    df = self.load_DataFrame5()
    self.line_Plot(df, st)

  def line_plot_data6(self, st):
    df = self.load_DataFrame6()
    self.line_Plot(df, st)

  def line_plot_data7(self, st):
    df = self.load_DataFrame7()
    self.line_Plot(df, st)


  def time_2_freq_conversion(self, df, Fx, str1):
    X = scipy.fft.fft(Fx)
    N = len(X)
    n = np.arange(N)
    # get the sampling rate
    sr = 1 / (10000)
    T = N/sr
    freq = n/T 

    # Get the one-sided specturm
    n_oneside = N//2
    # get the one side frequency
    f_oneside = freq[:n_oneside]

    plt.figure(figsize = (60, 10))
    plt.plot(f_oneside, np.abs(X[:n_oneside]), 'b')
    plt.xlim(0, 0.5*(1e-7))
    plt.ylim(0, 3.5*(1e7))
    st = "Frequency_"
    st+=str1
    st+=" (Hz)"
    plt.xlabel(st)
    st = "FFT Amplitude |"
    st+= str1
    st+="(freq)|"
    plt.ylabel(st)
    plt.show()

    # convert frequency to hour
    # t_h = 1/f_oneside / (10000)
    # plt.figure(figsize=(12,6))
    # plt.plot(t_h, np.abs(X[:n_oneside])/n_oneside)
    # plt.xlabel('Period ($second$)')
    # plt.show()



    
    
    





    

  def Fx_fft_data(self, df):
    Fx = np.array(df.Fx)
    Fy = np.array(df.Fy)
    Fz = np.array(df.Fz)
    self.time_2_freq_conversion(df, Fx, "X")
    self.time_2_freq_conversion(df, Fy, "Y")
    self.time_2_freq_conversion(df, Fz, "Z")

  def Fx_fft_data1(self):
    df = self.load_DataFrame1()
    self.Fx_fft_data(df)

  def Fx_fft_data2(self):
    df = self.load_DataFrame2()
    self.Fx_fft_data(df)

  def Fx_fft_data3(self):
    df = self.load_DataFrame3()
    self.Fx_fft_data(df)

  def Fx_fft_data4(self):
    df = self.load_DataFrame4()
    self.Fx_fft_data(df)

  def Fx_fft_data5(self):
    df = self.load_DataFrame5()
    self.Fx_fft_data(df)

  def Fx_fft_data6(self):
    df = self.load_DataFrame6()
    self.Fx_fft_data(df)

  def Fx_fft_data7(self):
    df = self.load_DataFrame7()
    self.Fx_fft_data(df)


  def dtw1(self, df, df1, x_start, x_end, col_no):
    query = df.iloc[x_start:x_end,col_no]
    template = df1.iloc[x_start:x_end,col_no]

    align_matrix = dtw(query, template, keep_internals=True)

    print(align_matrix)

    align_matrix.plot(type="twoway")
    print(align_matrix.normalizedDistance)


    # dtw(query, template, keep_internals=True, 
    # step_pattern=rabinerJuangStepPattern(6, "c"))\
    # .plot(type="twoway",offset=-2)
    # print(asymmetricP0)

    # ## See the recursion relation, as formula and diagram
    # print(rabinerJuangStepPattern(6,"c"))
    # rabinerJuangStepPattern(6,"c").plot()

    # # Use a windowing restrain
    # alignment = dtw(query, template, keep_internals=True, 
    # window_type="sakoechiba", window_args={'window_size': 10})\
    # .plot()
    

  def dtw_data1(self):
    df = self.load_DataFrame1()
    df1 = self.load_DataFrame2()
    self.dtw1(df, df1, 0, 10000, 1)

def main():
   cd = Chatter_Detection()
   cd.dtw_data1()



if __name__ == "__main__":
  main()

!dtw

# !dtw [-h] [--step_pattern STEP_PATTERN] query reference

#@title

def main():
  cd = Chatter_Detection()
  print("TEST 1")
  cd.Fx_fft_data1()
  print("TEST 2")
  cd.Fx_fft_data2()
  print("TEST 3")
  cd.Fx_fft_data3()
  print("TEST 4")
  cd.Fx_fft_data4()
  print("TEST 5")
  cd.Fx_fft_data5()
  print("TEST 6")
  cd.Fx_fft_data6()
  print("TEST 7")
  cd.Fx_fft_data7()
  




if __name__ == "__main__":
  main()

#@title

def main():
  cd = Chatter_Detection()
  ###########################
  # df1 = cd.load_Data1()
  # print(df1)
  # cd.data_to_csv(df1,"1")
  # df2 = cd.load_Data2()
  # print(df2)
  # cd.data_to_csv(df2,"2")
  # df3 = cd.load_Data3()
  # print(df3)
  # cd.data_to_csv(df3,"3")
  # df4 = cd.load_Data4()
  # print(df4)
  # cd.data_to_csv(df4,"4")
  # df5 = cd.load_Data5()
  # print(df5)
  # cd.data_to_csv(df5,"5")
  # df6 = cd.load_Data6()
  # print(df6)
  # cd.data_to_csv(df6,"6")
  # df7 = cd.load_Data7()
  # print(df7)
  # cd.data_to_csv(df7,"7")
  ###########################
  # cd.load_DataFrame1()
  # cd.load_DataFrame2()
  # cd.load_DataFrame3()
  # cd.load_DataFrame4()
  # cd.load_DataFrame5()
  # cd.load_DataFrame6()
  # cd.load_DataFrame7()
  ###########################
  print("TEST 1")
  cd.line_plot_data1("1")
  print("TEST 2")
  cd.line_plot_data2("2")
  print("TEST 3")
  cd.line_plot_data3("3")
  print("TEST 4")
  cd.line_plot_data4("4")
  print("TEST 5")
  cd.line_plot_data5("5")
  print("TEST 6")
  cd.line_plot_data6("6")
  print("TEST 7")
  cd.line_plot_data7("7")
  #########################





if __name__ == "__main__":
  main()

